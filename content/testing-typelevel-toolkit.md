+++
title = "Testing the typelevel toolkit"
date = 2023-09-25
slug = "testing-typelevel-toolkit"
language="en"
draft = true
[extra]
description = "How do you test a meta library that is meant to be used via `scala-cli`? And also, how do you automatize the tests for every platform that the meta library supports? Here's how we did in a weekend full of `sbt`_-fu_"
+++

The [Typelevel toolkit] is a metalibrary including some **great libraries** by [Typelevel], that was created to speed up the development of cross-platform applications in Scala and that I happily maintain since its creation. It's the Typelevel's flavour of the official [Scala Toolkit], a set of libraries to perform common programming tasks, that got its own section, full of examples, in the [official Scala documentation](https://docs.scala-lang.org/toolkit/introduction.html).

One of the vaunts of the Typelevel's stack is the fact that (almost) every library is published for the all the **three officially supported Scala platforms: JVM, JS and Native**, and for this reason every library is **heavily tested** against every supported platform and Scala version, to ensure a near perfect cross-compatibility.

Since its creation the [Typelevel toolkit] was lacking any sort of testing, mainly due to the fact that it is a mere collection of already battle tested libraries, so why bothering writing tests for it? As [this bug](https://github.com/typelevel/toolkit/issues/49) promptly reminded us, the main goal of the toolkit is to provide the most seamless experience while using [scala-cli]. 

Ideally you should be able to write:

{% codeBlock(title="helloWorld.scala") %}
```scala
//> using toolkit typelevel:latest

import cats.effect.*

object Hello extends IOApp.Simple:
  def run = IO.println("Hello World!")
```
{% end %}

and calling `scala-cli run {,--js,--native} helloWorld.scala` should **Just Workâ„¢** printing `"Hello World!"` to the console.

To be 100% sure we needed CI tests indeed.

## Planning the tests

What had to be tested though? All the included libraries are already tested, some of them are built using other included libraries, so some sort of **cross testing** was already done. What we were really interested in was always **being sure that scala-cli is always able to compile scripts written using the toolkit**. And what's the best way to ensure that `scala-cli` can compile a script written with the toolkit if not using `scala-cli` itself? 

`Pause for dramatic effect`

The coarse idea that [Arman](https://github.com/armanbilge) and I had in mind was to have a CI doing the following:
- **Locally publishing** the toolkit artifact
- Passing the artifact's version to a bunch of **pre-baked parametrized scripts**
- **Running** the scripts with `scala-cli`
- Be happy if every exit code is **0**

The **third step** in particular could have been implemented in a couple of ways:
1) Installing `scala-cli` in the CI image via GitHub Actions, call it from the tests code, and gather the results
2) Since `scala-cli` is a [native executable generated by GraalVM Native Image](https://scala-cli.virtuslab.org/docs/under-the-hood) and the corresponding jvm artifact [is distributed](https://repo1.maven.org/maven2/org/virtuslab/scala-cli/cli_3/), using it as a dependency and calling its main method in the tests.

We decided to follow the latter, as we didn't want to **mangle the GitHub Actions CI file** or relying on the **timely publication of the updated scala-cli GitHub Action**. Also, [sbt] is a superb tool for instrumenting this kind of tests: since it downloads automatically the latest scala-cli artifact we didn't need to have scala-cli installed locally, the version we are testing in particular. The build would be more self-contained and the scala-cli artifact version will be managed as every other dependency by [scala-steward](https://github.com/scala-steward-org/scala-steward).

> **BONUS EXAMPLE**: Using `scala-cli` in `scala-cli` to compile a `scala-cli` script
>{% codeBlock(title="recursiveScalaCli.scala", color="green") %}
```scala
//> using dep org.virtuslab.scala-cli::cli::1.0.4

import scala.cli.ScalaCli

object ScalaCliApp extends App:
    ScalaCli.main(Array("compile", "foo.scala"))
```
{%end%}

## First tentative: using the dependency in tests

In order to publish the artifacts locally before testing we needed a new `tests` project and to establish this relationship:

{% codeBlock(title="build.sbt") %}
```scala
//...
lazy val root = tlCrossRootProject.aggregate(
  toolkit, 
  toolkitTest,
  tests
)
//...
lazy val tests = project
  .in(file("tests"))
  .settings(
    name := "tests",
    Test / test := (Test / test).dependsOn(toolkit.jvm / publishLocal).value
  )
//...
```
{%end%}

In this way the `test` sbt command will always run a `publishLocal` of the jvm flavor of the toolkit artifact. The project then needed to be set to **not publish its** artifact and to have some dependencies added to actually write the tests. The `scala-cli` dependency needed some trickery to use the Scala 3 artifact (the only one published) in Scala 2.13 as well.

{% codeBlock(title="build.sbt") %}
```scala
//...
lazy val tests = project
  .in(file("tests"))
  .settings(
    name := "tests",
    Test / test := (Test / test).dependsOn(toolkit.jvm / publishLocal).value,
    // Required to use the scala 3 artifact with scala 2.13
    scalacOptions ++= {
      if (scalaBinaryVersion.value == "2.13") Seq("-Ytasty-reader") else Nil
    },
    libraryDependencies ++= Seq(
      "org.typelevel" %% "munit-cats-effect" % "2.0.0-M3" % Test,
      // This is needed to write scripts' body into files
      "co.fs2" %% "fs2-io" % "3.9.2" % Test,
      "org.virtuslab.scala-cli" %% "cli" % "1.0.4" % Test cross (CrossVersion.for2_13Use3)
    )
  )
  .enablePlugins(NoPublishPlugin)
//...
```
{%end%}

The last bit needed was a way to add to the scripts' body which version of the artifact we were publishing right before the testing step and which Scala version we were running on, in order to test it properly. The only place were this **(non-static)** information was present was the build itself, but we needed to have them **as an information in the source code**. We definitively needed some sbt trickery to make it happen.

There is an unspoken rule about the Scala community (or in the sbt users community to be precise) that you may already know about: "If you need some kind of sbt trickery, [eed3si9n] probably wrote a sbt plugin for that". 

This was our case with [sbt-buildinfo], a sbt plugin whose punchline is "_I know this because build.sbt knows this_". As you'll discover later, **sbt-buildinfo has been the corner stone of our second and more exhausting approach**, but what briefly does is generating Scala source from your build definitions, and thus makes build information available in the source code too.

As `scalaVersion` and `version` are two information that are injected by default, we just needed to add the plugin into `project/plugins.sbt` and enabling it on `tests` in the build:

{% codeBlock(title="projects/plugins.sbt") %}
```scala
//...
addSbtPlugin("com.eed3si9n" % "sbt-buildinfo" % "0.11.0")
```
{%end%}

{% codeBlock(title="build.sbt") %}
```scala
//...
lazy val tests = project
  .in(file("tests"))
  .settings(
    name := "tests",
    Test / test := (Test / test).dependsOn(toolkit.jvm / publishLocal).value,
    // Required to use the scala 3 artifact with scala 2.13
    scalacOptions ++= {
      if (scalaBinaryVersion.value == "2.13") Seq("-Ytasty-reader") else Nil
    },
    libraryDependencies ++= Seq(
      "org.typelevel" %% "munit-cats-effect" % "2.0.0-M3" % Test,
      // This is needed to write scripts' body into files
      "co.fs2" %% "fs2-io" % "3.9.2" % Test,
      "org.virtuslab.scala-cli" %% "cli" % "1.0.4" % Test cross (CrossVersion.for2_13Use3)
    )
  )
  .enablePlugins(NoPublishPlugin, BuildInfoPlugin)
//...
```
{%end%}

**Time to write the tests!** The first thing that was needed was a way to write on a temporary file the body of the script, including the artifact and Scala version, and then submit the file to scala-cli main method:

{% codeBlock(title="ToolkitTests.scala") %}
```scala
package org.typelevel.toolkit

import munit.CatsEffectSuite
import cats.effect.IO
import fs2.Stream
import fs2.io.file.Files
import scala.cli.ScalaCli
import buildinfo.BuildInfo.{version, scalaVersion}

class ToolkitCompilationTest extends CatsEffectSuite {

  testRun("Toolkit should compile a simple Hello Cats Effect") {
    s"""|import cats.effect._
        |
        |object Hello extends IOApp.Simple {
        |  def run = IO.println("Hello toolkit!")
        |}"""
  }

  def testRun(testName: String)(scriptBody: String): Unit =
    test(testName)(
      Files[IO]
        .tempFile(None, "", "-toolkit.scala", None)
        .use { path =>
            val header = List(
              s"//> using scala ${BuildInfo.scalaVersion}",
              s"//> using toolkit typelevel:${BuildInfo.version}",
            ).mkString("", "\n", "\n")
          Stream(header, scriptBody.stripMargin)
            .through(Files[IO].writeUtf8(path))
            .compile
            .drain >> IO.delay(
            ScalaCli.main(Array("run", path.toString))
          )
        }
    )
}
```
{%end%}

And with this easy and lean approach we were finally able to **test the toolkit**! :tada::tada::tada::tada::tada:

`Another pause for dramatic effect`

Except we weren't really testing everything: the `js` and `native` artifact weren't tested by this approach, as the `tests` project is a jvm only project depending on `toolkit.jvm`. We needed a more general/agnostic solution.

## BuildInfo magic and Java Instrumentation


[Typelevel toolkit]: https://typelevel.org/toolkit/
[Typelevel]: https://github.com/typelevel/
[Scala Toolkit]: https://github.com/scala/toolkit/
[scala-cli]: https://scala-cli.virtuslab.org/
[sbt]: https://www.scala-sbt.org/
[eed3si9n]: https://github.com/eed3si9n
[sbt-buildinfo]: https://github.com/sbt/sbt-buildinfo
[scala-steward]: https://github.com/scala-steward-org/scala-steward

- Trasformare runtime error in compile errors
- cross platform con fs2, invocando java e dichiarando male la dipendenza