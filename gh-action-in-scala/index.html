<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8; X-Content-Type-Options=nosniff" http-equiv=Content-Type><meta content="frame-ancestors 'none'; base-uri 'self';" http-equiv=Content-Security-Policy><meta content="index, follow" name=robots><meta content="3 days" name=revisit-after><meta content="Antonio Gelameris" name=author><title>Writing a GitHub Action with Scala.js | TonioGela's</title><meta content="Writing a GitHub Action with Scala.js | TonioGela's" name=title><meta content="Writing a GitHub Action with Scala.js | TonioGela's" property=og:title><meta content="Writing a GitHub Action with Scala.js | TonioGela's" property=twitter:title><meta content="How to use scala-cli and the Typelevel Toolkit to super charge your GitHub CI.
" name=description><meta content="How to use scala-cli and the Typelevel Toolkit to super charge your GitHub CI.
" property=og:description><meta content="How to use scala-cli and the Typelevel Toolkit to super charge your GitHub CI.
" property=twitter:description><meta content=website property=og:type><meta content=https://toniogela.dev/gh-action-in-scala/ property=og:url><meta content=summary property=twitter:card><meta content=https://toniogela.dev/gh-action-in-scala/ property=twitter:url><meta content=@toniogela name=twitter:site><meta content=@toniogela name=twitter:creator><meta content="width=device-width,initial-scale=1.0,maximum-scale=3" name=viewport><link href=https://toniogela.dev/rss.xml rel=alternate title=RSS type=application/rss+xml><link href="https://toniogela.dev/favicon.ico?h=fcd8599b2c3f8e3cb97b" rel="shortcut icon" type=image/x-icon><link href="https://toniogela.dev/favicon.ico?h=fcd8599b2c3f8e3cb97b" rel=icon type=image/x-icon><link href="https://toniogela.dev/colors.css?h=ff2263b4ebe229c8bdc6" as=style rel=preload><link href="
    https://toniogela.dev/avatar.webp?h=bb598620204fd77b7659
" as=image rel=preload><link crossorigin href=https://giscus.app rel=preconnect><link href="https://toniogela.dev/colors.css?h=ff2263b4ebe229c8bdc6" integrity="sha512-o0dvhjSBealgvuJzmYvFePyVuQvaOn3W76rseE83rvGCQTtaLHrVmd71648TAvmxyTRRKgHUBshRCelRiGIyng==" rel=stylesheet><script integrity="sha512-DKtiGDYXXQYuisRMLzYB5k06+5giy0VlJem3LveN+feK32OGPWVltPBsc7Zuxstr4WQqJhOzQkWpH4QDPhuyLg==" src="https://toniogela.dev/instantpage-5.1.0.js?h=fa5c34371df3acd378bd" async defer type=module></script><body data-instant-allow-external-links><nav class=overlord id=overlord><figure class=mini_logo><a aria-label=Homepage href=https://toniogela.dev style=background-image:url(https://toniogela.dev/avatar.webp)></a></figure><h5><a aria-label=Homepage href=https://toniogela.dev>TonioGela's</a></h5></nav><section class=post_container><article><h1 class=article_title><a href=https://toniogela.dev/gh-action-in-scala/ id=article_link>Writing a GitHub Action with Scala.js</a></h1><ul class="frontmatter frontmatter_page" id=frontmatter><li><time class=article_time datetime=2023-05-18>May 18, 2023</time><li class=dotDivider><li>1792 words<li class=dotDivider><li>9 min</ul><p>Some months ago, I discussed with a DevOps colleague the need for a custom GitHub Action at <code>$work</code>. The action we needed had to perform many tasks that weren't present in any action we could find, so we planned to write our own.<p>The chances were limited: there was the evergreen option to embed a <strong>gigantic shell script</strong> in the ci file (dealing with evergreen problems like escaping, quoting and indentation), the also evergreen option to <strong>commit the script</strong>, or we could have written our <strong>own GitHub action</strong>.<p>The last option was the most interesting one. Writing business logic in a more structured language than bash was desirable, but we had to face the fact that, according to the documentation, only two <a href=https://docs.github.com/en/actions/creating-actions/about-custom-actions#types-of-actions>types of actions</a> exist (if you don't consider composite ones): <code>Docker Container Actions</code> and <code>Javascript Actions</code>.<p>Since no one had any intention whatsoever to write javascript code and <a href=https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action>Docker Container Actions</a> had all the features we needed, we resorted to using one of them (despite their limitations in terms of compatibility).<p>Even though this <u>scarcely interesting success story</u> has a happy ending, a question emerged during the developments: <code>Is it possible to write a Github Action with Scala.js?</code><blockquote><p>Also, I asked myself <code>Is it still possible to survive as a software developer in 2023 without ever having written a single line of javascript?</code>: you'll find the answer below.</blockquote><p><strong>TLDR</strong>: yes and <a href=https://github.com/armanbilge>@armanbilge</a> did it in a couple of repositories like <a href=https://github.com/typelevel/await-cirrus>this one</a>, so in this post, we'll dissect his approach to create a how-to guide. Thank you, Arman! ‚ù§Ô∏è<h2 id=creating-a-simple-action><a class=anchor href=#creating-a-simple-action>Creating a simple action</a></h2><p>The action we'll create will be a <strong>simple adder</strong> that will <code>sum up two numbers</code> that can be either defined in the build file or one of the results of one of the previous steps.<h3 id=metadata><a class=anchor href=#metadata>Metadata</a></h3><p>According to its <a href=https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions>metadata syntax</a> page, every action defined in a repository requires an <code>action.yml</code> file that describes your action's inputs, outputs and run configuration.<p>Our action will have two required inputs and a single output, and it will run using node 16:<div class=code-window><div class=code-title style=color:#000;background-color:#6d98ba><span class=dot-red></span><span class=dot-yellow></span><span class=dot-green></span> action.yml</div><div class=code-body><pre class=language-yml data-lang=yml style=color:#c0c5ce;background-color:#2b303b><code class=language-yml data-lang=yml><span style=color:#bf616a>name</span><span>: '</span><span style=color:#a3be8c>Scala.js adder</span><span>'
</span><span style=color:#bf616a>description</span><span>: '</span><span style=color:#a3be8c>Summing two numbers, but with Scala.js</span><span>'
</span><span style=color:#bf616a>inputs</span><span>:
</span><span>  </span><span style=color:#bf616a>number-one</span><span>:
</span><span>    </span><span style=color:#bf616a>description</span><span>: '</span><span style=color:#a3be8c>The first number</span><span>'
</span><span>    </span><span style=color:#bf616a>required</span><span>: </span><span style=color:#d08770>true
</span><span>  </span><span style=color:#bf616a>number-two</span><span>:
</span><span>    </span><span style=color:#bf616a>description</span><span>: '</span><span style=color:#a3be8c>The second number</span><span>'
</span><span>    </span><span style=color:#bf616a>required</span><span>: </span><span style=color:#d08770>true
</span><span style=color:#bf616a>outputs</span><span>:
</span><span>  </span><span style=color:#bf616a>result</span><span>:
</span><span>    </span><span style=color:#bf616a>description</span><span>: "</span><span style=color:#a3be8c>The sum of the two inputs</span><span>"
</span><span style=color:#bf616a>runs</span><span>:
</span><span>  </span><span style=color:#bf616a>using</span><span>: '</span><span style=color:#a3be8c>node16</span><span>'
</span><span>  </span><span style=color:#bf616a>main</span><span>: '</span><span style=color:#a3be8c>index.js</span><span>'
</span></code></pre></div></div><h3 id=business-logic-requirements><a class=anchor href=#business-logic-requirements>Business logic requirements</a></h3><p>Once the metadata file is defined, we'll have to write the business logic, but we need to address a few issues:<ul><li>How do we produce a runnable js file?<li>How do we read the action's inputs?<li>How do we write the action's outputs?</ul><p>The most straightforward and potent tool that will produce <u>javascript code from a single Scala file</u> is undoubtedly <a href=https://github.com/VirtusLab/scala-cli><code>scala-cli</code></a>, with its ability to define in a few lines packaging, platform and dependencies setting.<p>Let's create in our repository a scala file with the required settings to produce a js module using a specific js and scala version:<div class=code-window><div class=code-title><span class=dot-red></span><span class=dot-yellow></span><span class=dot-green></span> index.scala</div><div class=code-body><pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#65737e>//> using scala "3.2.2"
</span><span style=color:#65737e>//> using platform "js"
</span><span style=color:#65737e>//> using jsVersion "1.13.1"
</span><span style=color:#65737e>//> using jsModuleKind "common"
</span><span>
</span><span style=color:#b48ead>object </span><span style=color:#ebcb8b>index </span><span style=color:#b48ead>extends </span><span style=color:#a3be8c>App</span><span>:
</span><span>    println("</span><span style=color:#a3be8c>Hello world</span><span>")
</span></code></pre></div></div><p>Packaging this file is as simple as running the command <code>scala-cli --power package -f index.scala</code> (we'll reuse this command later in our CI). This command will produce an <code>index.js</code> file that can run locally using <code>node ./index.js</code>.<p>Now that we can produce a runnable js file, it's time to create an actual GitHub action. The <a href=https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action>official documentation for javascript actions</a> recommends using the <a href=https://github.com/actions/toolkit><code>GitHub Actions Toolkit Node.js module</code></a> to speed up development (an intelligent person will probably use it,) but the Actions' runtime offers an alternative.<p>Digging deep into the metadata syntax documentation, in the <a href=https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs>inputs</a> section, you'll find an interesting paragraph:<blockquote><p>When you specify an input in a workflow file or use a default input value, GitHub creates an environment variable for the input with the name <code>INPUT_&lt;VARIABLE_NAME></code>. The environment variable created converts input names to uppercase letters and replaces spaces with <code>_</code> characters.</blockquote><p>So to get our input parameters, reading the environment variables <code>INPUT_NUMBER-ONE</code> and <code>INPUT_NUMBER-TWO</code> will be enough.<p>Last but not least, we need to find a way to define our action's output. Picking up the shovel again and digging further into the documentation, we'll discover <a href=https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs>a section</a> that enlightens us about the existence of a <code>GITHUB_OUTPUT</code> environment variable containing a file's path. This file will serve as an output buffer for the currently running step, and using it is as simple as writing the string <code>&lt;output_variable_name>=&lt;value></code> in it.<p>In our case, we'll have to write <code>result=&lt;sum of the inputs></code> in the file at path <code>$GITHUB_OUTPUT</code>, and we'll be done.<p>To sum up, we need a library/framework/stack that offers comfy APIs to read the content of environment variables and write stuff into files that have been compiled for Scala.js.<p>Unluckily the Scala standard library won't be enough even for such a simple task (unless you'll manually call some node.js APIs). If only there was <strong>a tech stack offering a resource-safe, referentially transparent way to perform these operations and a nice asynchronous API to call other processes, like other command line tools</strong>!<h3 id=typelevel-toolkit><a class=anchor href=#typelevel-toolkit>Typelevel toolkit</a></h3><p>Luckily for everybody, such a stack exists. The <a href=https://typelevel.org/>Typelevel</a> libraries are published for many Scala versions and for every platform Scala supports, including <a href=https://typelevel.org/platforms/native/>Scala native</a>. <a href=https://typelevel.org/platforms/js/>Most of them</a> can be used in a node.js action.<p>The most straightforward way to test this stack's fundamental libraries is using the Typelevel toolkit. The toolkit is a meta library that includes (among the others) <a href=https://typelevel.org/cats-effect/>Cats Effect</a>, <a href=https://fs2.io/#/io>fs2-io</a> for streaming, <a href=https://ben.kirw.in/decline/effect.html>a library to parse command line arguments</a>, <a href=https://circe.github.io/circe/>a JSON serde that supports automatic Scala 3 derivation</a> and <a href=https://http4s.org/v0.23/docs/client.html>an HTTP client</a>.<p>To use the toolkit, it's enough to declare it as a dependency in our scala-cli script:<div class=code-window><div class=code-title><span class=dot-red></span><span class=dot-yellow></span><span class=dot-green></span> index.scala</div><div class=code-body><pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#65737e>//> using scala "3.2.2"
</span><span style=color:#65737e>//> using platform "js"
</span><span style=color:#65737e>//> using jsVersion "1.13.1"
</span><span style=color:#65737e>//> using jsModuleKind "common"
</span><span style=color:#65737e>//> using dep "org.typelevel::toolkit::latest.release"
</span><span>
</span><span style=color:#b48ead>object </span><span style=color:#ebcb8b>index </span><span style=color:#b48ead>extends </span><span style=color:#a3be8c>App</span><span>:
</span><span>    println("</span><span style=color:#a3be8c>Hello world</span><span>")
</span></code></pre></div></div><p>Now it's time to write an input reading function: we can use <code>cats.effect.std.Env</code> to access the environment variables<pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#b48ead>import </span><span>cats.effect.</span><span style=color:#ebcb8b>IO
</span><span style=color:#b48ead>import </span><span>cats.effect.std.</span><span style=color:#ebcb8b>Env
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>getInput</span><span>(</span><span style=color:#bf616a>input</span><span>: </span><span style=color:#ebcb8b>String</span><span>): </span><span style=color:#ebcb8b>IO</span><span>[</span><span style=color:#ebcb8b>Option</span><span>[</span><span style=color:#ebcb8b>String</span><span>]] =
</span><span>  </span><span style=color:#ebcb8b>Env</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].get(</span><span style=color:#b48ead>s</span><span>"</span><span style=color:#a3be8c>INPUT_</span><span>${input.toUpperCase.replace(</span><span style=color:#d08770>' '</span><span>, </span><span style=color:#d08770>'_'</span><span>)}")
</span></code></pre><p>With the same method, we can get the output file path and write the output in it:<pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#b48ead>import </span><span>fs2.io.file.{</span><span style=color:#ebcb8b>Files</span><span>, </span><span style=color:#ebcb8b>Path</span><span>}
</span><span style=color:#b48ead>import </span><span>fs2.</span><span style=color:#ebcb8b>Stream
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>outputFile</span><span>: </span><span style=color:#ebcb8b>IO</span><span>[</span><span style=color:#ebcb8b>Path</span><span>] =
</span><span>  </span><span style=color:#ebcb8b>Env</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].get("</span><span style=color:#a3be8c>GITHUB_OUTPUT</span><span>").map(_.get).map(</span><span style=color:#ebcb8b>Path</span><span>.apply) </span><span style=color:#65737e>// unsafe Option.get
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>setOutput</span><span>(</span><span style=color:#bf616a>name</span><span>: </span><span style=color:#ebcb8b>String</span><span>, </span><span style=color:#bf616a>value</span><span>: </span><span style=color:#ebcb8b>String</span><span>): </span><span style=color:#ebcb8b>IO</span><span>[</span><span style=color:#ebcb8b>Unit</span><span>] =
</span><span>  outputFile.flatMap(path =>
</span><span>    </span><span style=color:#ebcb8b>Stream</span><span>[</span><span style=color:#ebcb8b>IO</span><span>, </span><span style=color:#ebcb8b>String</span><span>](</span><span style=color:#b48ead>s</span><span>"${name}</span><span style=color:#a3be8c>=</span><span>${value}")
</span><span>      .through(</span><span style=color:#ebcb8b>Files</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].writeUtf8(path))
</span><span>      .compile
</span><span>      .drain
</span><span>  )
</span></code></pre><p>Last but not least, we can write the logic of our application:<pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#b48ead>import </span><span>cats.effect.</span><span style=color:#ebcb8b>IOApp
</span><span>
</span><span style=color:#b48ead>object </span><span style=color:#ebcb8b>index </span><span style=color:#b48ead>extends </span><span style=color:#a3be8c>IOApp</span><span>.</span><span style=color:#ebcb8b>Simple</span><span>:
</span><span>  </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>run </span><span>= </span><span style=color:#b48ead>for </span><span>{
</span><span>    number1 &lt;- getInput("</span><span style=color:#a3be8c>number-one</span><span>").map(_.get.toInt) </span><span style=color:#65737e>// unsafe
</span><span>    number2 &lt;- getInput("</span><span style=color:#a3be8c>number-two</span><span>").map(_.get.toInt) </span><span style=color:#65737e>// unsafe
</span><span>    _ &lt;- setOutput("</span><span style=color:#a3be8c>result</span><span>", </span><span style=color:#b48ead>s</span><span>"${number1 + number2}")
</span><span>  } </span><span style=color:#b48ead>yield </span><span>()
</span></code></pre><p>The whole action implementation will then be<div class=code-window><div class=code-title><span class=dot-red></span><span class=dot-yellow></span><span class=dot-green></span> index.scala</div><div class=code-body><pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#65737e>//> using scala "3.2.2"
</span><span style=color:#65737e>//> using platform "js"
</span><span style=color:#65737e>//> using jsVersion "1.13.1"
</span><span style=color:#65737e>//> using jsModuleKind "common"
</span><span style=color:#65737e>//> using dep "org.typelevel::toolkit::latest.release"
</span><span>
</span><span style=color:#b48ead>import </span><span>cats.effect.{</span><span style=color:#ebcb8b>ExitCode</span><span>, </span><span style=color:#ebcb8b>IO</span><span>, </span><span style=color:#ebcb8b>IOApp</span><span>}
</span><span style=color:#b48ead>import </span><span>cats.effect.std.</span><span style=color:#ebcb8b>Env
</span><span style=color:#b48ead>import </span><span>fs2.io.file.{</span><span style=color:#ebcb8b>Files</span><span>, </span><span style=color:#ebcb8b>Path</span><span>}
</span><span style=color:#b48ead>import </span><span>fs2.</span><span style=color:#ebcb8b>Stream
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>getInput</span><span>(</span><span style=color:#bf616a>input</span><span>: </span><span style=color:#ebcb8b>String</span><span>): </span><span style=color:#ebcb8b>IO</span><span>[</span><span style=color:#ebcb8b>Option</span><span>[</span><span style=color:#ebcb8b>String</span><span>]] =
</span><span>  </span><span style=color:#ebcb8b>Env</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].get(</span><span style=color:#b48ead>s</span><span>"</span><span style=color:#a3be8c>INPUT_</span><span>${input.toUpperCase.replace(</span><span style=color:#d08770>' '</span><span>, </span><span style=color:#d08770>'_'</span><span>)}")
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>outputFile</span><span>: </span><span style=color:#ebcb8b>IO</span><span>[</span><span style=color:#ebcb8b>Path</span><span>] =
</span><span>  </span><span style=color:#ebcb8b>Env</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].get("</span><span style=color:#a3be8c>GITHUB_OUTPUT</span><span>").map(_.get).map(</span><span style=color:#ebcb8b>Path</span><span>.apply) </span><span style=color:#65737e>// unsafe Option.get
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>setOutput</span><span>(</span><span style=color:#bf616a>name</span><span>: </span><span style=color:#ebcb8b>String</span><span>, </span><span style=color:#bf616a>value</span><span>: </span><span style=color:#ebcb8b>String</span><span>): </span><span style=color:#ebcb8b>IO</span><span>[</span><span style=color:#ebcb8b>Unit</span><span>] =
</span><span>  outputFile.flatMap(path =>
</span><span>    </span><span style=color:#ebcb8b>Stream</span><span>[</span><span style=color:#ebcb8b>IO</span><span>, </span><span style=color:#ebcb8b>String</span><span>](</span><span style=color:#b48ead>s</span><span>"${name}</span><span style=color:#a3be8c>=</span><span>${value}")
</span><span>      .through(</span><span style=color:#ebcb8b>Files</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].writeUtf8(path))
</span><span>      .compile
</span><span>      .drain
</span><span>  )
</span><span>
</span><span style=color:#b48ead>object </span><span style=color:#ebcb8b>index </span><span style=color:#b48ead>extends </span><span style=color:#a3be8c>IOApp</span><span>.</span><span style=color:#ebcb8b>Simple</span><span>:
</span><span>  </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>run </span><span>= </span><span style=color:#b48ead>for </span><span>{
</span><span>    number1 &lt;- getInput("</span><span style=color:#a3be8c>number-one</span><span>").map(_.get.toInt) </span><span style=color:#65737e>// unsafe Option.get
</span><span>    number2 &lt;- getInput("</span><span style=color:#a3be8c>number-two</span><span>").map(_.get.toInt) </span><span style=color:#65737e>// unsafe Option.get
</span><span>    _ &lt;- setOutput("</span><span style=color:#a3be8c>result</span><span>", </span><span style=color:#b48ead>s</span><span>"${number1 + number2}")
</span><span>  } </span><span style=color:#b48ead>yield </span><span>()
</span></code></pre></div></div><details><summary>Safer and shorter alternative that uses decline</summary> <div class=code-window><div class=code-title><span class=dot-red></span><span class=dot-yellow></span><span class=dot-green></span> index.scala</div><div class=code-body><pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#65737e>//> using scala "3.2.2"
</span><span style=color:#65737e>//> using platform "js"
</span><span style=color:#65737e>//> using jsVersion "1.13.1"
</span><span style=color:#65737e>//> using jsModuleKind "common"
</span><span style=color:#65737e>//> using dep "org.typelevel::toolkit::latest.release"
</span><span>
</span><span style=color:#b48ead>import </span><span>cats.effect.{</span><span style=color:#ebcb8b>IO</span><span>, </span><span style=color:#ebcb8b>ExitCode</span><span>}
</span><span style=color:#b48ead>import </span><span>cats.syntax.all.*
</span><span style=color:#b48ead>import </span><span>fs2.</span><span style=color:#ebcb8b>Stream
</span><span style=color:#b48ead>import </span><span>fs2.io.file.{</span><span style=color:#ebcb8b>Files</span><span>, </span><span style=color:#ebcb8b>Path</span><span>}
</span><span style=color:#b48ead>import </span><span>com.monovore.decline.</span><span style=color:#ebcb8b>Opts
</span><span style=color:#b48ead>import </span><span>com.monovore.decline.effect.</span><span style=color:#ebcb8b>CommandIOApp
</span><span>
</span><span style=color:#b48ead>val </span><span style=color:#bf616a>args </span><span>= (
</span><span>  </span><span style=color:#ebcb8b>Opts</span><span>.env[</span><span style=color:#ebcb8b>Int</span><span>]("</span><span style=color:#a3be8c>INPUT_NUMBER-ONE</span><span>", "</span><span style=color:#a3be8c>The first number</span><span>"),
</span><span>  </span><span style=color:#ebcb8b>Opts</span><span>.env[</span><span style=color:#ebcb8b>Int</span><span>]("</span><span style=color:#a3be8c>INPUT_NUMBER-TWO</span><span>", "</span><span style=color:#a3be8c>The second number</span><span>"),
</span><span>  </span><span style=color:#ebcb8b>Opts</span><span>.env[</span><span style=color:#ebcb8b>String</span><span>]("</span><span style=color:#a3be8c>GITHUB_OUTPUT</span><span>", "</span><span style=color:#a3be8c>The file of the output</span><span>").map(</span><span style=color:#ebcb8b>Path</span><span>.apply)
</span><span>)
</span><span>
</span><span style=color:#b48ead>object </span><span style=color:#ebcb8b>index </span><span style=color:#b48ead>extends </span><span style=color:#a3be8c>CommandIOApp</span><span>("</span><span style=color:#a3be8c>adder</span><span>", "</span><span style=color:#a3be8c>Summing two numbers</span><span>"):
</span><span>  </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>main </span><span>= args.mapN { (one, two, path) =>
</span><span>    </span><span style=color:#ebcb8b>Stream</span><span>(</span><span style=color:#b48ead>s</span><span>"</span><span style=color:#a3be8c>result=</span><span>${one + two}")
</span><span>      .through(</span><span style=color:#ebcb8b>Files</span><span>[</span><span style=color:#ebcb8b>IO</span><span>].writeUtf8(path))
</span><span>      .compile
</span><span>      .drain
</span><span>      .as(</span><span style=color:#ebcb8b>ExitCode</span><span>.</span><span style=color:#ebcb8b>Success</span><span>)
</span><span>  }
</span></code></pre></div></div></details><p>Now that the logic is in place, we must produce a <code>.js</code> file and <strong>commit it</strong> in the repo, as the action runtime won't interpret our Scala code. Scala-cli helps us: running <code>scala-cli --power package -f index.scala</code> produces an <code>index.js</code> file that our action can run.<p>The content of our repository should now be this:<pre class=language-tree data-lang=tree style=color:#c0c5ce;background-color:#2b303b><code class=language-tree data-lang=tree><span style=color:#bf616a>.
</span><span style=color:#a3be8c>‚îú‚îÄ‚îÄ</span><span> action.yml
</span><span style=color:#a3be8c>‚îú‚îÄ‚îÄ</span><span> index.js
</span><span style=color:#a3be8c>‚îî‚îÄ‚îÄ</span><span> index.scala
</span></code></pre><p>It's time to check if our action work as intended.<h3 id=testing-never-hurts><a class=anchor href=#testing-never-hurts>Testing never hurts</a></h3><p>There are a few ways to test if an action you're developing works as intended. The best one is probably using <a href=https://github.com/nektos/act>act</a>, as the feedback cycle will be shorter. Sadly, the last time I checked <code>sbt</code> (and possibly <code>scala-cli</code>) was included only in the complete runtime image, requiring you to download the whole ~20GB container image.<p>The quickest way to test the action is to run it directly on the GitHub Runners and set up its CI to test the logic: the only required thing is a workflow file under <code>.github/workflows</code>.<p>As we must commit the transpiled version of our source code, a preliminary check that the <code>.js</code> file corresponds to the source <code>.scala</code> file is a good idea. The easiest way to test that they match is to recompile the <code>.scala</code> file with scala-cli and use the good old <code>git diff</code>:<pre class=language-yml data-lang=yml style=color:#c0c5ce;background-color:#2b303b><code class=language-yml data-lang=yml><span style=color:#bf616a>check-js-file</span><span>:
</span><span>  </span><span style=color:#bf616a>runs-on</span><span>: </span><span style=color:#a3be8c>ubuntu-latest
</span><span>  </span><span style=color:#bf616a>steps</span><span>:
</span><span>    - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>actions/checkout@v3                     </span><span style=color:#65737e># Checking out our code
</span><span>    - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>actions/setup-java@v3
</span><span>      </span><span style=color:#bf616a>with</span><span>:
</span><span>        </span><span style=color:#bf616a>distribution</span><span>: </span><span style=color:#a3be8c>temurin
</span><span>        </span><span style=color:#bf616a>java-version</span><span>: </span><span style=color:#d08770>17
</span><span>    - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>coursier/cache-action@v6
</span><span>    - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>VirtusLab/scala-cli-setup@main          </span><span style=color:#65737e># Installing scala-cli
</span><span>    - </span><span style=color:#bf616a>run</span><span>: </span><span style=color:#a3be8c>scala-cli --power package -f index.scala </span><span style=color:#65737e># Recompiling our code
</span><span>    - </span><span style=color:#bf616a>run</span><span>: </span><span style=color:#a3be8c>git diff --quiet index.js                </span><span style=color:#65737e># Silently failing if there's any difference
</span></code></pre><blockquote><p>One thing to consider is that we used <code>latest.release</code> as the toolkit version, making our build non reproducible. Pinning the dependencies' versions is usually a good idea. To achieve reproducibility is possible to pin a specific scala-cli version too using <code>--cli-version &lt;version></code>. Also, pinning each action version (i.e. <code>- uses:VirtusLab/scala-cli-setup@v1.0.0-RC2</code>) might decrease the chances that your CI will produce a different js file (and thus failing) in the future.</blockquote><p>Once sure that the transpiled version of our code is correct, we can run our action and test its output directly in its own CI:<pre class=language-yml data-lang=yml style=color:#c0c5ce;background-color:#2b303b><code class=language-yml data-lang=yml><span style=color:#bf616a>test-action-itself</span><span>:
</span><span>  </span><span style=color:#bf616a>needs</span><span>: </span><span style=color:#a3be8c>check-js-file                </span><span style=color:#65737e># There's no point in testing the wrong version
</span><span>  </span><span style=color:#bf616a>runs-on</span><span>: </span><span style=color:#a3be8c>ubuntu-latest
</span><span>  </span><span style=color:#bf616a>steps</span><span>:
</span><span>    - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>actions/checkout@v3
</span><span>    - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>./                        </span><span style=color:#65737e># Here we'll use the action itself
</span><span>      </span><span style=color:#bf616a>id</span><span>: </span><span style=color:#a3be8c>test-gh-action
</span><span>      </span><span style=color:#bf616a>with</span><span>:
</span><span>        </span><span style=color:#bf616a>number-one</span><span>: </span><span style=color:#d08770>3
</span><span>        </span><span style=color:#bf616a>number-two</span><span>: </span><span style=color:#d08770>9
</span><span>    - </span><span style=color:#bf616a>run</span><span>: </span><span style=color:#a3be8c>test 12 -eq "${{ steps.test-gh-action.outputs.result }}"
</span></code></pre><p>The last action uses the good old <code>test</code> command (aka <code>[</code>) to check the action's output for the specified inputs.<details><summary>Complete CI file</summary> <div class=code-window><div class=code-title style=color:#1a2539;background-color:#a3be8c><span class=dot-red></span><span class=dot-yellow></span><span class=dot-green></span> .github/workflows/ci.yml</div><div class=code-body><pre class=language-yml data-lang=yml style=color:#c0c5ce;background-color:#2b303b><code class=language-yml data-lang=yml><span style=color:#bf616a>name</span><span>: </span><span style=color:#a3be8c>Continuos Integration
</span><span style=color:#d08770>on</span><span>:
</span><span>  </span><span style=color:#bf616a>pull_request</span><span>:
</span><span>    </span><span style=color:#bf616a>branches</span><span>: ['</span><span style=color:#a3be8c>**</span><span>']
</span><span>  </span><span style=color:#bf616a>push</span><span>:
</span><span>    </span><span style=color:#bf616a>branches</span><span>: ['</span><span style=color:#a3be8c>**</span><span>', '</span><span style=color:#a3be8c>!update/**</span><span>', '</span><span style=color:#a3be8c>!pr/**</span><span>']
</span><span>
</span><span style=color:#bf616a>jobs</span><span>:
</span><span>  </span><span style=color:#bf616a>check-js-file</span><span>:
</span><span>    </span><span style=color:#bf616a>runs-on</span><span>: </span><span style=color:#a3be8c>ubuntu-latest
</span><span>    </span><span style=color:#bf616a>steps</span><span>:
</span><span>      - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>actions/checkout@v3
</span><span>      - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>actions/setup-java@v3
</span><span>        </span><span style=color:#bf616a>with</span><span>:
</span><span>          </span><span style=color:#bf616a>distribution</span><span>: </span><span style=color:#a3be8c>temurin
</span><span>          </span><span style=color:#bf616a>java-version</span><span>: </span><span style=color:#d08770>17
</span><span>      - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>coursier/cache-action@v6
</span><span>      - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>VirtusLab/scala-cli-setup@main
</span><span>      - </span><span style=color:#bf616a>run</span><span>: </span><span style=color:#a3be8c>scala-cli --power --cli-version 1.0.0-RC2 package -f index.scala
</span><span>      - </span><span style=color:#bf616a>run</span><span>: </span><span style=color:#a3be8c>git diff --quiet index.js
</span><span>
</span><span>  </span><span style=color:#bf616a>test-action-itself</span><span>:
</span><span>    </span><span style=color:#bf616a>needs</span><span>: </span><span style=color:#a3be8c>check-js-file
</span><span>    </span><span style=color:#bf616a>runs-on</span><span>: </span><span style=color:#a3be8c>ubuntu-latest
</span><span>    </span><span style=color:#bf616a>steps</span><span>:
</span><span>      - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>actions/checkout@v3
</span><span>      - </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>./
</span><span>        </span><span style=color:#bf616a>id</span><span>: </span><span style=color:#a3be8c>test-gh-action
</span><span>        </span><span style=color:#bf616a>with</span><span>:
</span><span>          </span><span style=color:#bf616a>number-one</span><span>: </span><span style=color:#d08770>3
</span><span>          </span><span style=color:#bf616a>number-two</span><span>: </span><span style=color:#d08770>9
</span><span>      - </span><span style=color:#bf616a>run</span><span>: </span><span style=color:#a3be8c>test 12 -eq "${{ steps.test-gh-action.outputs.result }}"
</span></code></pre></div></div></details><h3 id=using-the-action><a class=anchor href=#using-the-action>Using the action</a></h3><p>To let the world use your new and shiny Scala.js-powered GitHub Action, commit every mentioned file in a public repository, let's say <a href=https://github.com/TonioGela/test-gh-action><code>TonioGela/test-gh-action</code></a>, and use the repository slug in every other action on the whole GitHub:<pre class=language-yml data-lang=yml style=color:#c0c5ce;background-color:#2b303b><code class=language-yml data-lang=yml><span style=color:#65737e># ...
</span><span>  - </span><span style=color:#bf616a>name</span><span>: </span><span style=color:#a3be8c>Sum numbers with Scala
</span><span>    </span><span style=color:#bf616a>id</span><span>: </span><span style=color:#a3be8c>this-is-the-id
</span><span>    </span><span style=color:#bf616a>uses</span><span>: </span><span style=color:#a3be8c>TonioGela/test-gh-action@main </span><span style=color:#65737e># specify a branch name, a version or a commit sha
</span><span>    </span><span style=color:#bf616a>with</span><span>:
</span><span>        </span><span style=color:#bf616a>number-one</span><span>: </span><span style=color:#d08770>3
</span><span>        </span><span style=color:#bf616a>number-two</span><span>: </span><span style=color:#d08770>9
</span><span style=color:#65737e># ...
</span></code></pre><h3 id=further-considerations><a class=anchor href=#further-considerations>Further considerations</a></h3><p>The example in this post is meant to show how to use a combination of tools and libraries to create a Github Action and doesn't show the true power of the Typelevel stack. A recent addition to <a href=https://fs2.io/#/io>fs2-io</a> that can be handy in the context of an action might be the <a href="https://fs2.io/#/io?id=processes">Processes APIs</a>, with whom you can invoke external commands/tools handling their stdin, stdout, and exit codes:<pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#b48ead>import </span><span>cats.effect.{</span><span style=color:#ebcb8b>Concurrent</span><span>, </span><span style=color:#ebcb8b>MonadCancelThrow</span><span>}
</span><span style=color:#b48ead>import </span><span>fs2.io.process.{</span><span style=color:#ebcb8b>Processes</span><span>, </span><span style=color:#ebcb8b>ProcessBuilder</span><span>}
</span><span style=color:#b48ead>import </span><span>fs2.text
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>helloProcess</span><span>[</span><span style=color:#ebcb8b>F</span><span>[_]: </span><span style=color:#ebcb8b>Concurrent</span><span>: </span><span style=color:#ebcb8b>Processes</span><span>]: </span><span style=color:#ebcb8b>F</span><span>[</span><span style=color:#ebcb8b>String</span><span>] =
</span><span>  </span><span style=color:#ebcb8b>ProcessBuilder</span><span>("</span><span style=color:#a3be8c>echo</span><span>", "</span><span style=color:#a3be8c>Hello, process!</span><span>").spawn.use { process =>
</span><span>    process.stdout.through(text.utf8.decode).compile.string
</span><span>  }
</span></code></pre><p>The toolkit includes the <code>Ember</code> client and its <code>circe</code> integration, with whom you can easily call any external service and deserialize its output in a case class:<pre class=language-scala data-lang=scala style=color:#c0c5ce;background-color:#2b303b><code class=language-scala data-lang=scala><span style=color:#b48ead>import </span><span>cats.effect.</span><span style=color:#ebcb8b>IO
</span><span style=color:#b48ead>import </span><span>cats.syntax.all.*
</span><span style=color:#b48ead>import </span><span>io.circe.</span><span style=color:#ebcb8b>Decoder
</span><span style=color:#b48ead>import </span><span>org.http4s.circe.jsonOf
</span><span style=color:#b48ead>import </span><span>org.http4s.</span><span style=color:#ebcb8b>EntityDecoder
</span><span style=color:#b48ead>import </span><span>org.http4s.ember.client.</span><span style=color:#ebcb8b>EmberClientBuilder
</span><span>
</span><span style=color:#b48ead>case class </span><span style=color:#ebcb8b>Foo</span><span>(bar:</span><span style=color:#ebcb8b>String</span><span>) </span><span style=color:#b48ead>derives </span><span style=color:#a3be8c>Decoder
</span><span style=color:#b48ead>given </span><span style=color:#ebcb8b>EntityDecoder</span><span>[</span><span style=color:#ebcb8b>IO</span><span>, </span><span style=color:#ebcb8b>Foo</span><span>] = jsonOf[</span><span style=color:#ebcb8b>IO</span><span>, </span><span style=color:#ebcb8b>Foo</span><span>]
</span><span>
</span><span style=color:#ebcb8b>EmberClientBuilder</span><span>.default[</span><span style=color:#ebcb8b>IO</span><span>].build.use { client =>
</span><span>    client.expect[</span><span style=color:#ebcb8b>Foo</span><span>](</span><span style=color:#b48ead>s</span><span>"</span><span style=color:#a3be8c>https://foo.bar</span><span>").flatMap(foo => </span><span style=color:#ebcb8b>IO</span><span>.println(foo))
</span><span>}
</span></code></pre><p>The toolkit's site contains a <a href=https://typelevel.org/toolkit/examples.html>few examples</a> of what you can do with it. Go take a look üòÑ<h2 id=conclusions><a class=anchor href=#conclusions>Conclusions</a></h2><p>Despite being a bit unripe, I find this approach fascinating and easy to use (in particular if you don't know any <code>js</code> in 2023 üòá).<p>In the future, I might consider rewriting in Scala.js the <a href=https://github.com/actions/toolkit>actions/toolkit</a> library or a part of it (I might have to learn javascript ü§¶). If you want to contribute, feel free to <a href=https://discord.com/users/372358874243661825>contact me</a>.<p>One thing that's worth exploring is the interaction with <a href=https://github.com/scala-steward-org/scala-steward>Scala-Steward</a>. Can the CI be set up to re-generate the js and commit the result? Probably yes, with <code>postUpdateHooks</code>. Is it desirable? I'm still not sure.<p>You'll find the code written in the post in <a href=https://github.com/TonioGela/test-gh-action>this repository</a><p>Enjoy!</article><script data-repo-id="MDEwOlJlcG9zaXRvcnkzNzA0MDc0NDc=" async crossorigin data-category=Q&A data-category-id=DIC_kwDOFhP4F84CeeYj data-emit-metadata=1 data-input-position=bottom data-lang=en data-loading=lazy data-mapping=pathname data-reactions-enabled=1 data-repo=TonioGela/blog data-strict=0 data-theme=dark_dimmed src=https://giscus.app/client.js></script>